############ Removing Ununsual Observations ##############
##########################################################
# Remove unusual observations from initial data frame (CT value less than 10)
deriv = deriv %>% filter(deriv$cpD1 >= 10)
# Read in raw cycle data - may need to combine multiple files
cycle1 = read.csv(file = "2018_11_1_plate.csv", header = FALSE)
cycle2 = read.csv(file = "2018_11_2_plate.csv", header = FALSE)
cycle = as.data.frame(cbind(cycle1, cycle2))
# Create complete set of reaction data (derivative and cycle)
reaction = Stack(deriv_complete, cycle1)
# Remove repeat labeling
replace = reaction[7:10,]
reaction = reaction[-c(1:4, 7:10),]
reaction = Stack(replace, reaction)
# Transpose so column headers at top
reaction = as.data.frame(t(reaction))
reaction = reaction[,-c(6:7)]
# Replace column names with first row
colnames(reaction) <- as.character(unlist(reaction[1,]))
reaction = reaction[-1,]
colnames(reaction)[5] = "cpD1"
reaction$cpD1 = as.numeric(as.character(reaction$cpD1))
# Filter unusual observations (CT value less than 10)
unusual_obs_2018_11 = reaction %>% filter(reaction$cpD1 < 10)
# Write CSV file
#write.csv(unusual_obs_2018_11, file="Unusual_Obs_2018_11.csv")
# ### COMPLETED UNUSUAL OBSERVATIONS REMOVAL/REPORTING ###
##########################################################
################# Calibrated Data Framing ################
##########################################################
library("rowr")
# Create/Write data frame for Calibrated values
calib_data = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_data = calib_data[order(calib_data$starting_quantity),]
calib_data$starting_quantity = as.numeric(as.character(calib_data$starting_quantity))
calib_data$cpD1 = as.numeric(as.character(calib_data$cpD1))
test1 = filter(calib_data, reaction_type=="test1")[,5]
allP = filter(calib_data, reaction_type=="all_products")[,4:5]
calib_data = as.data.frame(cbind.fill(allP, test1, fill = NA))
colnames(calib_data) = c("startq", 'allP', "test1")
# Format starting quantity values as decimals, not scientific notation
calib_data$startq=as.factor(format(calib_data$startq, scientific=FALSE))
calib_data$startq=as.factor(calib_data$startq)
write.csv(calib_data, file = "calib_2018_8.csv")
### COMPLETED CALIBRATED DATA FRAME ###
##########################################################
############### Experimental Data Framing ################
##########################################################
# Create/Write data frame for Experimental values
exp_data = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_data = exp_data[order(exp_data$starting_quantity),]
# # Remove first and last rows (unnecessary labeling)
# exp_data = exp_data[-1,]
# exp_data = exp_data[-nrow(exp_data),]
exp_data$cpD1 = as.numeric(as.character(exp_data$cpD1))
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
### Finding invalid observations ###
# Find invalid observations - Find counts of each unique sampleID; remove ones with count not equal to 2 from data frame
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
countsne2$Var1 = as.numeric(as.character(countsne2$Var1))
# Remove observations with count not equal to 2 from data set
exp_data = exp_data[!exp_data$sampleID %in% countsne2$Var1,]
# Create empty vectors for for-loop to input cpD1 values
test1.exp = c()
allP.exp = c()
sampleID.exp = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(exp_data$sampleID)){
id.exp = toString(exp_data$sampleID[i])
if(i %% 2 == 1){
sampleID.exp = c(sampleID.exp, id.exp)
}
val = toString(exp_data$reaction_type[i])
if(strcmp(val, "test1")){
test1.exp = c(test1.exp, exp_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP.exp = c(allP.exp, exp_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by sample ID, convert to data frame
exp_data = as.data.frame(cbind(sampleID.exp, test1.exp, allP.exp))
exp_data$test1.exp = as.numeric(as.character(exp_data$test1.exp))
exp_data$allP.exp = as.numeric(as.character(exp_data$allP.exp))
write.csv(exp_data, file = "exp_2018_8.csv")
### COMPLETED EXPERIMENTAL DATA FRAME ###
write.csv(calib_data, file = "calib_2018_11.csv")
write.csv(exp_data, file = "exp_2018_11.csv")
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing")
# MONTH 1 (2018_6 / JUNE) CALIBRATED DATA FRAME
calib_data_6 = read.csv("./2018_6/calib_2018_6.csv")
# MONTH 1 (2018_6 / JUNE) CALIBRATED DATA FRAME
calib_data_6 = read.csv("./2018_6/calib_2018_6.csv")
View(calib_data_6)
calib_data_6$month = strrep('june', length(calib_data_6))
calib_data_6$month ='june'
# MONTH 1 (2018_6 / JUNE) CALIBRATED DATA FRAME
calib_data_6 = read.csv("./2018_6/calib_2018_6.csv")[,-1]
calib_data_6$month ='june'
calib_data_6
calib_data_8 = read.csv("./2018_8/calib_2018_8.csv")[,-1]
calib_data_8$month ='aug'
calib_data_8
calib_data_11 = read.csv("./2018_11/calib_2018_11.csv")[,-1]
calib_data_11$month ='nov'
calib_data_11
# Combined Calib d.f. for all months
calib_data = rbind(calib_data_6, calib_data_8, calib_data_11)
View(calib_data)
# Create dummy varible columns for each month
calib_data$june = ifelse(str_detect(calib_data[,4], "june"), 1, 0)
calib_data$aug = ifelse(str_detect(calib_data[,4], "aug"), 1, 0)
calib_data = calib_data[,-4]
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/StressSplicing")
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing")
library(stringr)
library(tidyverse)
library(dplyr)
#setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing")
dat = read.csv(file = "Plant_Height_Update.csv", header = TRUE)
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/vqtl")
dat = dat %>% filter(str_detect(dat$Height..in.., "N") == FALSE)
dat = dat %>% filter(str_detect(dat$Genotype, "B") == FALSE)
dat$Genotype = str_remove(dat$Genotype, " ") #removes any empty space in Mo###
#setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/vqtl")
dat = read.csv(file = "Plant_Height_Update.csv", header = TRUE)
#Take out unneeded IBMB###, NA, B73 loci
dat = dat %>% filter(str_detect(dat$Height..in.., "N") == FALSE)
dat = dat %>% filter(str_detect(dat$Genotype, "B") == FALSE)
dat$Genotype = str_remove(dat$Genotype, " ") #removes any empty space in Mo###
#Create Categorical Variables for PH207*Mo### and Mo### by gene breed
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Hybrid")
dat = cbind(dat, BreedType)
#Add in SNP info from Marker data CSV, beginning with column six
snpFull = read.csv(file = "IBM94markerset08seq.csv", header = TRUE)
snp = snpFull[,-(1:5)]
### Assigning Genotypes to Mo###
library(data.table)
#function takes the last three values of a string
substrRight <- function(x, n){
substr(x, nchar(x)-n+1, nchar(x))
}
#creating datasets exclusively containing the last three numbers
dat.num =cbind(dat, as.integer(substrRight(as.character(dat$Genotype), 3)))
snp.num = as.integer(substrRight(as.character(colnames(snp)), 3))
snp.new = data.frame(lapply(snp,as.character),stringsAsFactors=FALSE)
snpMatch = rbind(snp.num,snp.new)
snpMatch = transpose(snpMatch)
# creating matching Genotype columns to merge the data
colnames(snpMatch) = c("GenotypeNum")
datnames =names(dat.num)[-7]
colnames(dat.num) = c(datnames,"GenotypeNum")
dat2 = merge(dat.num,snpMatch, by.x = "GenotypeNum", by.y = "GenotypeNum",all.MoNum = all)
dat2 = dat2[order(dat2$Genotype, decreasing = FALSE),]
dat2 = dat2[,-1]
write.csv(dat2, "dat2.csv")
#####################################################################################
#####Adding marker location and chromosome#####
aux = matrix(snpFull$incre_new, nrow= 1)
aux = rbind(aux,snpFull$Chromosome)
other = as.data.frame(matrix(rep(0,12), nrow = 2))
aux = cbind(other,aux)
colnames(aux) = rep("",3241)
colnames(dat2) = rep("",3241)
dat3 = rbind(aux,dat2)
colnames(dat3) = c("AES", "Genotype", "Height", "Ear Angle", "Notes","BreedType", as.character(snpFull$markername))
dat3[1:10,1:10]
write.csv(dat3, file = "snpHeight.csv" ,
row.names = FALSE)
#####MAKE SURE TO DELETE THE EXTRA ZEROS IN [1:2,1:4] IN EXCEL AFTERWARDS#####
#Add in SNP info from Marker data CSV, beginning with column six
snpFull = read.csv(file = "IBM94markerset08seq.csv", header = TRUE)
library(stringr)
library(tidyverse)
library(dplyr)
#setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/vqtl")
dat = read.csv(file = "Plant_Height_Update.csv", header = TRUE)
#Take out unneeded IBMB###, NA, B73 loci
dat = dat %>% filter(str_detect(dat$Height..in.., "N") == FALSE)
dat = dat %>% filter(str_detect(dat$Genotype, "B") == FALSE)
dat$Genotype = str_remove(dat$Genotype, " ") #removes any empty space in Mo###
#Create Categorical Variables for PH207*Mo### and Mo### by gene breed
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Hybrid")
dat = cbind(dat, BreedType)
#Add in SNP info from Marker data CSV, beginning with column six
snpFull = read.csv(file = "../IBM94markerset08seq.csv", header = TRUE)
snp = snpFull[,-(1:5)]
### Assigning Genotypes to Mo###
library(data.table)
#function takes the last three values of a string
substrRight <- function(x, n){
substr(x, nchar(x)-n+1, nchar(x))
}
#creating datasets exclusively containing the last three numbers
dat.num =cbind(dat, as.integer(substrRight(as.character(dat$Genotype), 3)))
snp.num = as.integer(substrRight(as.character(colnames(snp)), 3))
snp.new = data.frame(lapply(snp,as.character),stringsAsFactors=FALSE)
snpMatch = rbind(snp.num,snp.new)
snpMatch = transpose(snpMatch)
# creating matching Genotype columns to merge the data
colnames(snpMatch) = c("GenotypeNum")
datnames =names(dat.num)[-7]
colnames(dat.num) = c(datnames,"GenotypeNum")
dat2 = merge(dat.num,snpMatch, by.x = "GenotypeNum", by.y = "GenotypeNum",all.MoNum = all)
dat2 = dat2[order(dat2$Genotype, decreasing = FALSE),]
dat2 = dat2[,-1]
write.csv(dat2, "dat2.csv")
#####################################################################################
#####Adding marker location and chromosome#####
aux = matrix(snpFull$incre_new, nrow= 1)
aux = rbind(aux,snpFull$Chromosome)
other = as.data.frame(matrix(rep(0,12), nrow = 2))
aux = cbind(other,aux)
colnames(aux) = rep("",3241)
colnames(dat2) = rep("",3241)
dat3 = rbind(aux,dat2)
colnames(dat3) = c("AES", "Genotype", "Height", "Ear Angle", "Notes","BreedType", as.character(snpFull$markername))
dat3[1:10,1:10]
write.csv(dat3, file = "snpHeight.csv" ,
row.names = FALSE)
#####MAKE SURE TO DELETE THE EXTRA ZEROS IN [1:2,1:4] IN EXCEL AFTERWARDS#####
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/SamplingPlan")
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/SamplingPlan")
### Sample plan data cleaning ###
library(stringr)
library(tidyverse)
library(dplyr)
### Sample plan data cleaning ###
library(stringr)
library(tidyverse)
library(dplyr)
#setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/SamplingPlan")
#############################################
##### formatting the Sampling Plan data #####
#############################################
dat = read.csv(file = "../2016_Clayton/Field Book (2016) - Clayton - Sampling Plan_TIDIED.csv", header = TRUE)
#filter out the recongizable MO###
dat = dat %>% filter(str_detect(dat$Genotype, "Mo") == TRUE)
#create the breedtype category
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Hybrid")
dat = cbind(BreedType, dat)
snpFull = read.csv(file = "../IBM94markerset08seq.csv", header = TRUE)
snp = snpFull[,-(1:5)]
#############################################
### matching the Mo### to their snp Values ##
#############################################
library(data.table)
#function takes the last n characters of a string
substrRight <- function(x, n){
substr(x, nchar(x)-n+1, nchar(x))
}
#creating datasets exclusively containing the last three numbers
dat.num =cbind(dat, as.integer(substrRight(as.character(dat$Genotype), 3)))
#produces warning sign about NA's for data that is not availible for invalid Mo###
snp.num = as.integer(substrRight(as.character(colnames(snp)), 3))
snp.new = data.frame(lapply(snp,as.character),stringsAsFactors=FALSE)
snpMatch = rbind(snp.num,snp.new)
snpMatch = transpose(snpMatch)
# creating matching Genotype columns to merge the data
#need = c(1,5,7,8,9,10,16) #column numbers of needed variables
#dat.num = dat.num[,need]
colnames(snpMatch) = "GenotypeNum"
#datnames =names(dat.num)
colnames(dat.num)[16] = "GenotypeNum"
dat2 = merge(dat.num,snpMatch, by.x = "GenotypeNum", by.y = "GenotypeNum",all.MoNum = all)
dat2 = dat2[order(dat2$Genotype, decreasing = FALSE),]
dat2 = dat2[,-1] #omit GenotypeNum
dat2[1:20, 1:20]
#write.csv(dat2, "SamplingPlan_dat2.csv")
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/Heirarchical")
library(MASS)
library(stringr)
## Ordinal Net package ##
library("ordinalNet")
# set directory to the Heirarchical folder
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/Heirarchical")
#### reading in and setting up calibrated data ####
# MONTH 1 (2018_6 / JUNE) CALIBRATED DATA FRAME
calib_data_6 = na.omit(read.csv("../2018_6/calib_2018_6.csv")[,-1])
calib_data_6$ztest1 = (calib_data_6$test1 - mean(calib_data_6$test1))/sd(calib_data_6$test1)
calib_data_6$zallP = (calib_data_6$allP - mean(calib_data_6$allP))/sd(calib_data_6$allP)
calib_data_6$month ='june'
#calib_data_6
# MONTH 2 (2018_8 / AUGUST) CALIBRATED DATA FRAME
calib_data_8 = na.omit(read.csv("../2018_8/calib_2018_8.csv")[,-1])
calib_data_8$ztest1 = (calib_data_8$test1 - mean(calib_data_8$test1))/sd(calib_data_8$test1)
calib_data_8$zallP = (calib_data_8$allP - mean(calib_data_8$allP))/sd(calib_data_8$allP)
calib_data_8$month ='aug'
#calib_data_8
# MONTH 3 (2018_11 / NOVEMBER) CALIBRATED DATA FRAME
calib_data_11 = na.omit(read.csv("../2018_11/calib_2018_11.csv")[,-1])
calib_data_11$ztest1 = (calib_data_11$test1 - mean(calib_data_11$test1))/sd(calib_data_11$test1)
calib_data_11$zallP = (calib_data_11$allP - mean(calib_data_11$allP))/sd(calib_data_11$allP)
calib_data_11$month ='nov'
#calib_data_11
# Combined Calib d.f. for all months
calib_data = rbind(calib_data_6, calib_data_8, calib_data_11)
# Create dummy varible columns for each month
calib_data$june = ifelse(str_detect(calib_data[,6], "june"), 1, 0)
calib_data$aug = ifelse(str_detect(calib_data[,6], "aug"), 1, 0)
calib_data = calib_data[,-6]
# Drop rows containing NA
calib_subset = calib_data[,c(1, 4:7)]
######
#### Plotting calibrated data ####
#graphing log starting quantity to cp values
plot(calib_data$allP,log(calib_data$startq), col = 'red', main = "Hierarchical Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data$test1,log(calib_data$startq), col = 'blue')
abline(lm(log(calib_data$startq)~calib_data$allP), col = 'red')
abline(lm(log(calib_data$startq)~calib_data$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
#graphing log starting quantity to cp values by month
#June
plot(calib_data_6$allP,log(calib_data_6$startq), col = 'red', main = "June Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data_6$test1,log(calib_data_6$startq), col = 'blue')
abline(lm(log(calib_data_6$startq)~calib_data_6$allP), col = 'red')
abline(lm(log(calib_data_6$startq)~calib_data_6$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
#August
plot(calib_data_8$allP,log(calib_data_8$startq), col = 'red', main = "August Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data_8$test1,log(calib_data_8$startq), col = 'blue')
abline(lm(log(calib_data_8$startq)~calib_data_8$allP), col = 'red')
abline(lm(log(calib_data_8$startq)~calib_data_8$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
#November
plot(calib_data_11$allP,log(calib_data_11$startq), col = 'red', main = "November Log Starting Quanitty vs. Cp Values",
ylab = "log(Starting Quantity)", xlab = "Cp Values" , xlim = c(5, 25), ylim = c(-6, 1))
points(calib_data_11$test1,log(calib_data_11$startq), col = 'blue')
abline(lm(log(calib_data_11$startq)~calib_data_11$allP), col = 'red')
abline(lm(log(calib_data_11$startq)~calib_data_11$test1), col = 'blue')
legend('topright', legend=c("Test 1", "All Products"),
col=c("blue", "red"), lty = 1, cex=0.8)
#####
hist(calib_data$allP, col = "red")
hist(calib_data$test1, col = "blue")
# ###### POLR models ######
# # Ordinal Logistic Regression Model
# model = polr(as.factor(calib_subset$startq) ~ ., data=calib_subset, Hess = TRUE)
# #(summary(model))
# (ctable <- coef(summary(model)))
# ## calculate and store p values
# p <- pnorm(abs(ctable[, "t value"]), lower.tail = FALSE) * 2
# options(scipen=999)
# ## combined table
# (ctable <- cbind(ctable, "p value" = p))
#
# ###### Ordinal Net models #######
#define ordinal model starq~zallP+ztest1+month
ordmod = ordinalNet(as.matrix(calib_subset[,2:5]), as.factor(calib_subset$startq))
summary(ordmod)
coef(ordmod, matrix=TRUE)
#kfold cv
set.seed(3)
ordfit = ordinalNetTune(as.matrix(calib_subset[,2:5]), as.factor(calib_subset$startq), family = "cumulative",
link = "logit", parallelTerms = TRUE, nonparallelTerms = TRUE,
warn = FALSE, printProgress = FALSE)
head(ordfit$loglik)
bestLambdaIndex = which.max(rowMeans(ordfit$loglik))
head(coef(ordfit$fit, matrix = TRUE, whichLambda = bestLambdaIndex))
###### Experimental Data #######
# MONTH 1 (2018_8 / AUGUST) EXPERIMENTAL DATA FRAME
exp_data_8 = na.omit(read.csv("../2018_8/exp_2018_8.csv")[,-1])
exp_data_8$ztest1 = (exp_data_8$test1 - mean(exp_data_8$test1))/sd(exp_data_8$test1)
exp_data_8$zallP = (exp_data_8$allP - mean(exp_data_8$allP))/sd(exp_data_8$allP)
exp_data_8$month ='aug'
exp_data_8$sampleID.exp = as.factor(exp_data_8$sampleID.exp)
#exp_data_8
# MONTH 2 (2018_6 / JUNE) EXPERIMENTAL DATA FRAME
exp_data_6 = na.omit(read.csv("../2018_6/exp_2018_6.csv")[,-c(1,5,6)])
exp_data_6$ztest1 = (exp_data_6$test1 - mean(exp_data_6$test1))/sd(exp_data_6$test1)
exp_data_6$zallP = (exp_data_6$allP - mean(exp_data_6$allP))/sd(exp_data_6$allP)
exp_data_6$month ='june'
#exp_data_6
# MONTH 3 (2018_11 / NOVEMBER) EXPERIMENTAL DATA FRAME
exp_data_11 = na.omit(read.csv("../2018_11/exp_2018_11.csv")[,-1])
exp_data_11$ztest1 = (exp_data_11$test1 - mean(exp_data_11$test1))/sd(exp_data_11$test1)
exp_data_11$zallP = (exp_data_11$allP - mean(exp_data_11$allP))/sd(exp_data_11$allP)
exp_data_11$month ='nov'
exp_data_11$sampleID.exp = as.factor(exp_data_11$sampleID.exp)
#exp_data_11
# Combined exp d.f. for all months
exp_data = rbind(exp_data_6, exp_data_8, exp_data_11)
# Create dummy varible columns for each month
exp_data$june = ifelse(str_detect(exp_data[,6], "june"), 1, 0)
exp_data$aug = ifelse(str_detect(exp_data[,6], "aug"), 1, 0)
exp_data = exp_data[,-6]
# Drop rows containing NA
exp_subset = exp_data[,c(1, 4:7)]
#### calculating experimental starting quantity ####
probmat = predict(ordfit$fit, as.matrix(exp_subset[,2:5]))
probmat[1:10,]
##### finding adjustment value and adjusted test 1 in calibrated #####
group = split.data.frame(calib_data, calib_data$startq)
adj <- function(AllP, Test1){
adjust = ave(AllP)-ave(Test1)
return(adjust)
}
adjval = NULL
for (k in group){
adjval = c(adjval,adj(k$allP, k$test1))
}
##### Creating a dataframe with the stq and adjustment values #########
calib_adj = cbind(unique(calib_data$startq), unique(adjval))
colnames(calib_adj) = c("startq", "adj")
#convert adjustment from picograms to femtograms (1:1000)
calib_adj$adj = (calib_adj$adj)*1000
# convert test1 and allp to femtograms
exp_data[,c(2,3)] = exp_data[,c(2,3)]*1000
# Apply probability matrix to the adjustment values using matrix multiplication
exp_data$exp.adjust = probmat%*%calib_adj$adj
# Create new column with stress product (VQTL input)
exp_data$exp.adjustTest1 = exp_data$test1.exp+exp_data$exp.adjust
# convert allP and adjusted test 1 to femtograms
exp_data$stress = exp_data$allP.exp - exp_data$exp.adjustTest1
boxplot(exp_data$allP.exp, exp_data$test1.exp, exp_data$stress, main = "Boxplot of Experimental All Products, Test 1, and Stress",
names =c("All Products", "Test 1", "Stress"), ylab = "Cp value", col =c("blue", "red", "green"))
hist(exp_data$stress, col = "light blue")
### analyzing negative stress ###
negstress = na.omit(ifelse(exp_data$stress<0,exp_data$stress,NA))
hist(negstress, col = "light green")
length(negstress)/length(exp_data$stress)
##### Creating a dataframe with the stq and adjustment values #########
calib_adj = as.data.frame(cbind(unique(calib_data$startq), unique(adjval)))
colnames(calib_adj) = c("startq", "adj")
#convert adjustment from picograms to femtograms (1:1000)
calib_adj$adj = (calib_adj$adj)*1000
# convert test1 and allp to femtograms
exp_data[,c(2,3)] = exp_data[,c(2,3)]*1000
# Apply probability matrix to the adjustment values using matrix multiplication
exp_data$exp.adjust = probmat%*%calib_adj$adj
# Create new column with stress product (VQTL input)
exp_data$exp.adjustTest1 = exp_data$test1.exp+exp_data$exp.adjust
# convert allP and adjusted test 1 to femtograms
exp_data$stress = exp_data$allP.exp - exp_data$exp.adjustTest1
boxplot(exp_data$allP.exp, exp_data$test1.exp, exp_data$stress, main = "Boxplot of Experimental All Products, Test 1, and Stress",
names =c("All Products", "Test 1", "Stress"), ylab = "Cp value", col =c("blue", "red", "green"))
hist(exp_data$stress, col = "light blue")
### analyzing negative stress ###
negstress = na.omit(ifelse(exp_data$stress<0,exp_data$stress,NA))
hist(negstress, col = "light green")
length(negstress)/length(exp_data$stress)
head(calib_adj)
View(exp_data)
### Write the exp data with the stress product as a new data frame for vqtl matching
write(exp_data, "Hierarchical_exp_data_stress.csv")
### Write the exp data with the stress product as a new data frame for vqtl matching
write.csv(exp_data, "Hierarchical_exp_data_stress.csv")
library(stringr)
library(tidyverse)
library(dplyr)
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/SamplingPlan")
#############################################
##### formatting the Sampling Plan data #####
#############################################
dat = read.csv(file = "../2016_Clayton/Field Book (2016) - Clayton - Sampling Plan_TIDIED.csv", header = TRUE)
#filter out the recongizable MO###
dat = dat %>% filter(str_detect(dat$Genotype, "Mo") == TRUE)
#create the breedtype category
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Hybrid")
dat = cbind(BreedType, dat)
snpFull = read.csv(file = "../IBM94markerset08seq.csv", header = TRUE)
snp = snpFull[,-(1:5)]
#############################################
### matching the Mo### to their snp Values ##
#############################################
library(data.table)
#function takes the last n characters of a string
substrRight <- function(x, n){
substr(x, nchar(x)-n+1, nchar(x))
}
#creating datasets exclusively containing the last three numbers
dat.num =cbind(dat, as.integer(substrRight(as.character(dat$Genotype), 3)))
#produces warning sign about NA's for data that is not availible for invalid Mo###
snp.num = as.integer(substrRight(as.character(colnames(snp)), 3))
snp.new = data.frame(lapply(snp,as.character),stringsAsFactors=FALSE)
snpMatch = rbind(snp.num,snp.new)
snpMatch = transpose(snpMatch)
# creating matching Genotype columns to merge the data
#need = c(1,5,7,8,9,10,16) #column numbers of needed variables
#dat.num = dat.num[,need]
colnames(snpMatch) = "GenotypeNum"
#datnames =names(dat.num)
colnames(dat.num)[16] = "GenotypeNum"
dat2 = merge(dat.num,snpMatch, by.x = "GenotypeNum", by.y = "GenotypeNum",all.MoNum = all)
dat2 = dat2[order(dat2$Genotype, decreasing = FALSE),]
dat2 = dat2[,-1] #omit GenotypeNum
dat2[1:20, 1:20]
#write.csv(dat2, "SamplingPlan_dat2.csv")
colnames(dat2)[4] = "sampleID"
#### Heirarchical Model Framing ####
HPlate = read.csv(file = "../Heirarchical/Hierarchical_exp_data_stress.csv")
View(HPlate)
colnames(HPlate)[2] = "sampleID"
class(HPlate$sampleID)
max(as.numeric(as.character(HPlate$sampleID))
)
max(as.numeric(as.character(HPlate[79:,2])))
HPlate[79:,2]
max(as.numeric(as.character(HPlate[79:465,2])))
View(dat2)
dim(dat2)
unique(dat2$Year)
