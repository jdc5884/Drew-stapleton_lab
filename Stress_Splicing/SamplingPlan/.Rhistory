BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Hybrid")
dat = cbind(BreedType, dat)
snpFull = read.csv(file = "../IBM94markerset08seq.csv", header = TRUE)
snp = snpFull[,-(1:5)]
#############################################
### matching the Mo### to their snp Values ##
#############################################
library(data.table)
#function takes the last n characters of a string
substrRight <- function(x, n){
substr(x, nchar(x)-n+1, nchar(x))
}
#creating datasets exclusively containing the last three numbers
dat.num =cbind(dat, as.integer(substrRight(as.character(dat$Genotype), 3)))
#produces warning sign about NA's for data that is not availible for invalid Mo###
snp.num = as.integer(substrRight(as.character(colnames(snp)), 3))
snp.new = data.frame(lapply(snp,as.character),stringsAsFactors=FALSE)
snpMatch = rbind(snp.num,snp.new)
snpMatch = transpose(snpMatch)
# creating matching Genotype columns to merge the data
#need = c(1,5,7,8,9,10,16) #column numbers of needed variables
#dat.num = dat.num[,need]
colnames(snpMatch) = "GenotypeNum"
#datnames =names(dat.num)
colnames(dat.num)[17] = "GenotypeNum"
dat2 = merge(dat.num,snpMatch, by.x = "GenotypeNum", by.y = "GenotypeNum",all.MoNum = all)
dat2 = dat2[order(dat2$Genotype, decreasing = FALSE),]
dat2 = dat2[,-1] #omit GenotypeNum
dat2[1:20, 1:20]
#write.csv(dat2, "SamplingPlan_dat2.csv")
########################################
######### Including plate data #########
########################################
colnames(dat2)[2] = "sampleID"
#
# # 2018_8 plate data #
# plate_8 = read.csv(file = , header = TRUE)
# colnames(plate_8)[2] = "sampleID"
# full_8 = merge(plate_8, dat2, by = "sampleID")
#
# #create one big dataframe containing all plate months
# #full = rbind(full_11, full_6, full_8)
#
# #### Heirarchical Model Framing ####
HPlate = read.csv(file = "../Heirarchical/Hierarchical_exp_data_stress.csv")
#split isolate the June month since the sampleID is availible for it
June = HPlate %>% filter(str_detect(HPlate$month, "june") == TRUE)
colnames(June)[2] = "Barcode"
June = merge(June, dat2, by = "Barcode")
#August and November Months
AugNov = HPlate %>% filter(str_detect(HPlate$month, "aug")|str_detect(HPlate$month, "nov"))
addmarker <- function(full, plate){
aux = matrix(snpFull$incre_new, nrow= 1)
aux = rbind(snpFull$Chromosome, aux)
zeros = dim(full)[2]-dim(aux)[2]
fillnames = names(full)[1:zeros]
other = as.data.frame(matrix(rep(0,2*zeros), nrow = 2)) #repeat the number of 0 as the number of variables
aux = cbind(other,aux)
colnames(aux) = rep("",dim(aux)[2])
colnames(full) = rep("",dim(aux)[2])
dat3 = rbind(aux,full)
colnames(dat3) = c(fillnames, as.character(snpFull$markername))
return(dat3)
}
View(AugNov)
June[1:10, 1"10"]
June[1:10, 1:10]
June[1:10, 10:20]
June[1:10, 20:30]
AugNov[1:20]
AugNov[1:20, 1:10]
dat2[1:20, 1:10]
dat = read.csv(file = "../2016_Clayton/Field Book (2016) - Clayton - Sampling Plan_TIDIED.csv", header = TRUE)
#filter out the recongizable MO###
dat = dat %>% filter(str_detect(dat$Genotype, "Mo") == TRUE)
#create the breedtype category
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Hybrid")
dat = cbind(BreedType, dat)
snpFull = read.csv(file = "../IBM94markerset08seq.csv", header = TRUE)
snp = snpFull[,-(1:5)]
#############################################
### matching the Mo### to their snp Values ##
#############################################
library(data.table)
#function takes the last n characters of a string
substrRight <- function(x, n){
substr(x, nchar(x)-n+1, nchar(x))
}
#creating datasets exclusively containing the last three numbers
dat.num =cbind(dat, as.integer(substrRight(as.character(dat$Genotype), 3)))
#produces warning sign about NA's for data that is not availible for invalid Mo###
snp.num = as.integer(substrRight(as.character(colnames(snp)), 3))
snp.new = data.frame(lapply(snp,as.character),stringsAsFactors=FALSE)
snpMatch = rbind(snp.num,snp.new)
snpMatch = transpose(snpMatch)
# creating matching Genotype columns to merge the data
#need = c(1,5,7,8,9,10,16) #column numbers of needed variables
#dat.num = dat.num[,need]
colnames(snpMatch) = "GenotypeNum"
#datnames =names(dat.num)
colnames(dat.num)[17] = "GenotypeNum"
dat2 = merge(dat.num,snpMatch, by.x = "GenotypeNum", by.y = "GenotypeNum",all.MoNum = all)
dat2 = dat2[order(dat2$Genotype, decreasing = FALSE),]
dat2 = dat2[,-c(1, 4)] #omit GenotypeNum
dat2[1:20, 1:20]
#write.csv(dat2, "SamplingPlan_dat2.csv")
dat2[1:10, 1:20]
names(AugNov)
#split isolate the June month since the sampleID is availible for it
June = HPlate %>% filter(str_detect(HPlate$month, "june") == TRUE)
colnames(June)[2] = "Barcode"
June = merge(June, dat2, by = "Barcode")
#August and November Months
AugNov = HPlate %>% filter(str_detect(HPlate$month, "aug")|str_detect(HPlate$month, "nov"))
#
# # 2018_8 plate data #
# plate_8 = read.csv(file = , header = TRUE)
# colnames(plate_8)[2] = "sampleID"
# full_8 = merge(plate_8, dat2, by = "sampleID")
#
# #create one big dataframe containing all plate months
# #full = rbind(full_11, full_6, full_8)
#
# #### Heirarchical Model Framing ####
HPlate = read.csv(file = "../Heirarchical/Hierarchical_exp_data_stress.csv")
#split isolate the June month since the sampleID is availible for it
June = HPlate %>% filter(str_detect(HPlate$month, "june") == TRUE)
colnames(June)[2] = "Barcode"
June = merge(June, dat2, by = "Barcode")
#August and November Months
AugNov = HPlate %>% filter(str_detect(HPlate$month, "aug")|str_detect(HPlate$month, "nov"))
names(AugNov)
colnames(AugNov)[1] = "sampleID"
AugNov = merge(AugNov, dat2, by = "sampleID")
dim(AugNov)
dim(dat2)
length(unique(AugNov$sampleID))
length(unique(dat2$sampleID))
colnames(dat2)[2] = "sampleID"
head(dat2$sampleID)
length(unique(dat2$sampleID))
AugNov = merge(AugNov, dat2, by = "sampleID")
dim(AugNov)
AugNov[1:10, 20:30]
match(a, b)
a = c(1,2,3,4,5)
b = c(1,2,6,7,8)
match(a, b)
a = c(1,2,3,4,5)
b = c(1,2,6,7,3)
match(a, b)
b = c(6,7,1,2,3)
match(a, b)
#making sure that non of the genotype information was matched to more than on obs
match(June$Barcode, AugNov$Barcode)
length(June$Barcode)
length(AugNov$Barcode)
#making sure that non of the genotype information was matched to more than on obs
intersect(June$Barcode, AugNov$Barcode)
#making sure that non of the genotype information was matched to more than on obs
length(intersect(June$Barcode, AugNov$Barcode))
length(unique(dat2$Barcode))
length(unique(dat2$sampleID))
dim(dat2)
#split isolate the June month since the sampleID is availible for it
June = HPlate %>% filter(str_detect(HPlate$month, "june") == TRUE)
View(June)
#August and November Months
AugNov = HPlate %>% filter(str_detect(HPlate$month, "aug")|str_detect(HPlate$month, "nov"))
dat2$sampleID[1]
names(dat2)
head(names(dat2))
head(names(dat2), 10)
head(dat2(,c(2,9)))
head(dat2[,c(2,9)])
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/2018_8")
##########################################################
############## QPCR PLATE & ADJUSTMENT MODEL #############
##########################################################
library(tidyr)
library(pracma)
library(stringr)
library(tidyverse)
library(dplyr)
library(MASS)
library(glm.predict)
library(Stack)
deriv.1<-read.csv(file = "2018_8_1_qPCR_Output.csv", header=FALSE)
deriv.2<-read.csv(file = "2018_8_2_qPCR_Output.csv", header=FALSE)
deriv.3=read.csv(file = "2018_8_3_qPCR_Output.csv", header=FALSE)
deriv_complete=as.data.frame(cbind(deriv.1, deriv.2, deriv.3))
deriv = deriv_complete
# Remove extra column
deriv = deriv[,-1]
# Transpose derivatives to be in equivalent format as raw plate data
deriv = as.data.frame(t(deriv), header=TRUE)
# Rename columns
colnames(deriv)=c("plateID", "reaction_type", "sampleID", "starting_quantity", "cpD1", "cpD2")
# Indicate if sample is NTC (negative control)
deriv['sampleID_NTC'] = grepl('NTC', deriv$sampleID)
# Remove NTC samples, indicator (T/F) column, and cpD2 values
ntc = which(deriv$sampleID_NTC)
deriv = deriv[-ntc,]
deriv = deriv[,-c(6,7)]
# Indicate if sample is 'Plus' or 'Minus'
deriv['sampleID_Minus'] = grepl('minus', deriv$sampleID)
# Remove 'Minus' values (include only gblock+ values), and indicator (T/F) column
minus = which(deriv$sampleID_Minus)
# IF "minus" RETURNS EMPTY VALUES, COMMENT OUT COMMAND BELOW
deriv = deriv[-minus,]
deriv = deriv[,-6]
# Remove two extra label rows from center of data frame
deriv['label.row'] = grepl('3', deriv$starting_quantity)
extra = which(deriv$label.row)
deriv = deriv[-extra,]
deriv = deriv[,-6]
deriv$cpD1 = as.numeric(as.character(deriv$cpD1))
### COMPLETED INITIAL DATA FRAMING ###
##########################################################
############ Removing Ununsual Observations ##############
##########################################################
# Remove unusual observations from initial data frame (CT value less than 10)
deriv = deriv %>% filter(deriv$cpD1 >= 10)
# Read in raw cycle data - may need to combine multiple files
cycle1 = read.csv(file = "2018_8_1_plate.csv", header = FALSE)
cycle2 = read.csv(file = "2018_8_2_plate.csv", header = FALSE)
cycle3 = read.csv(file = "2018_8_3_plate.csv", header = FALSE)
cycle = as.data.frame(cbind(cycle1, cycle2, cycle3))
# Create complete set of reaction data (derivative and cycle)
reaction = Stack(deriv_complete, cycle)
# Remove repeat labeling
replace = reaction[7:10,]
reaction = reaction[-c(1:4, 7:10),]
reaction = Stack(replace, reaction)
# Transpose so column headers at top
reaction = as.data.frame(t(reaction))
reaction = reaction[,-c(6:7)]
# Replace column names with first row
colnames(reaction) <- as.character(unlist(reaction[1,]))
reaction = reaction[-1,]
colnames(reaction)[5] = "cpD1"
reaction$cpD1 = as.numeric(as.character(reaction$cpD1))
# Filter unusual observations (CT value less than 10)
unusual_obs_2018_8 = reaction %>% filter(reaction$cpD1 < 10)
# Write CSV file
#write.csv(unusual_obs_2018_8, file="Unusual_Obs_2018_8.csv")
# ### COMPLETED UNUSUAL OBSERVATIONS REMOVAL/REPORTING ###
##########################################################
################# Calibrated Data Framing ################
##########################################################
library("rowr")
# Create/Write data frame for Calibrated values
calib_data = deriv %>% filter(str_detect(sampleID, "g"))
# Sort by starting quantity
calib_data = calib_data[order(calib_data$starting_quantity),]
calib_data$starting_quantity = as.numeric(as.character(calib_data$starting_quantity))
calib_data$cpD1 = as.numeric(as.character(calib_data$cpD1))
test1 = filter(calib_data, reaction_type=="test1")[,5]
allP = filter(calib_data, reaction_type=="all_products")[,4:5]
calib_data = as.data.frame(cbind.fill(allP, test1, fill = NA))
colnames(calib_data) = c("startq", 'allP', "test1")
# Format starting quantity values as decimals, not scientific notation
calib_data$startq=as.factor(format(calib_data$startq, scientific=FALSE))
calib_data$startq=as.factor(calib_data$startq)
write.csv(calib_data, file = "calib_2018_8.csv")
### COMPLETED CALIBRATED DATA FRAME ###
##########################################################
############### Experimental Data Framing ################
##########################################################
# Create/Write data frame for Experimental values
exp_data = deriv %>% filter(str_detect(sampleID, "g")==FALSE)
# Sort by starting quantity
exp_data = exp_data[order(exp_data$starting_quantity),]
# # Remove first and last rows (unnecessary labeling)
# exp_data = exp_data[-1,]
# exp_data = exp_data[-nrow(exp_data),]
exp_data$cpD1 = as.numeric(as.character(exp_data$cpD1))
# Order data by sampleID
exp_data = exp_data[order(exp_data$sampleID),]
### Finding invalid observations ###
# Find invalid observations - Find counts of each unique sampleID; remove ones with count not equal to 2 from data frame
counts = as.data.frame(table(exp_data$sampleID))
countsne2 = as.data.frame(filter(counts, !counts$Freq==2))
countsne2$Var1 = as.numeric(as.character(countsne2$Var1))
# Remove observations with count not equal to 2 from data set
exp_data = exp_data[!exp_data$sampleID %in% countsne2$Var1,]
# Create empty vectors for for-loop to input cpD1 values
test1.exp = c()
allP.exp = c()
sampleID.exp = c()
# For loop -- iterating thru starting quantity and reaction type to return cpD1 values
for(i in 1:length(exp_data$sampleID)){
id.exp = toString(exp_data$sampleID[i])
if(i %% 2 == 1){
sampleID.exp = c(sampleID.exp, id.exp)
}
val = toString(exp_data$reaction_type[i])
if(strcmp(val, "test1")){
test1.exp = c(test1.exp, exp_data$cpD1[i])
}
if(strcmp(val, "all_products")){
allP.exp = c(allP.exp, exp_data$cpD1[i])
}
}
# Bind test1 and allProd cpD1 values by sample ID, convert to data frame
exp_data = as.data.frame(cbind(sampleID.exp, test1.exp, allP.exp))
exp_data$test1.exp = as.numeric(as.character(exp_data$test1.exp))
exp_data$allP.exp = as.numeric(as.character(exp_data$allP.exp))
exp_data
View(exp_data)
library(stringr)
library(tidyverse)
library(dplyr)
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/SamplingPlan")
#############################################
##### formatting the Sampling Plan data #####
#############################################
dat = read.csv(file = "../2016_Clayton/Field Book (2016) - Clayton - Sampling Plan_TIDIED.csv", header = TRUE)
#filter out the recongizable MO###
dat = dat %>% filter(str_detect(dat$Genotype, "Mo") == TRUE)
#create the breedtype category
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Hybrid")
dat = cbind(BreedType, dat)
snpFull = read.csv(file = "../IBM94markerset08seq.csv", header = TRUE)
snp = snpFull[,-(1:5)]
#############################################
### matching the Mo### to their snp Values ##
#############################################
library(data.table)
#function takes the last n characters of a string
substrRight <- function(x, n){
substr(x, nchar(x)-n+1, nchar(x))
}
#creating datasets exclusively containing the last three numbers
dat.num =cbind(dat, as.integer(substrRight(as.character(dat$Genotype), 3)))
#produces warning sign about NA's for data that is not availible for invalid Mo###
snp.num = as.integer(substrRight(as.character(colnames(snp)), 3))
snp.new = data.frame(lapply(snp,as.character),stringsAsFactors=FALSE)
snpMatch = rbind(snp.num,snp.new)
snpMatch = transpose(snpMatch)
# creating matching Genotype columns to merge the data
#need = c(1,5,7,8,9,10,16) #column numbers of needed variables
#dat.num = dat.num[,need]
colnames(snpMatch) = "GenotypeNum"
#datnames =names(dat.num)
colnames(dat.num)[17] = "GenotypeNum"
dat2 = merge(dat.num,snpMatch, by.x = "GenotypeNum", by.y = "GenotypeNum",all.MoNum = all)
dat2 = dat2[order(dat2$Genotype, decreasing = FALSE),]
dat2 = dat2[,-c(1, 4)] #omit GenotypeNum
dat2[1:20, 1:20]
#write.csv(dat2, "SamplingPlan_dat2.csv")
########################################
######### Including plate data #########
########################################
colnames(dat2)[2] = "sampleID"
#
# # 2018_8 plate data #
# plate_8 = read.csv(file = , header = TRUE)
# colnames(plate_8)[2] = "sampleID"
# full_8 = merge(plate_8, dat2, by = "sampleID")
#
# #create one big dataframe containing all plate months
# #full = rbind(full_11, full_6, full_8)
#
# #### Heirarchical Model Framing ####
HPlate = read.csv(file = "../Heirarchical/Hierarchical_exp_data_stress.csv")
names(HPlate)
colnames(dat2)[2] = "sampleID.exp"
#split isolate the June month since the sampleID is availible for it
June = HPlate %>% filter(str_detect(HPlate$month, "june") == TRUE)
colnames(June)[2] = "Barcode"
June = merge(June, dat2, by = "Barcode")
#August and November Months
AugNov = HPlate %>% filter(str_detect(HPlate$month, "aug")|str_detect(HPlate$month, "nov"))
AugNov = merge(AugNov, dat2, by = "sampleID.exp")
#making sure that non of the genotype information was matched to more than on obs
length(intersect(June$Barcode, AugNov$Barcode))
intersect(June$Barcode, AugNov$Barcode)
#split isolate the June month since the sampleID is availible for it
June = HPlate %>% filter(str_detect(HPlate$month, "june") == TRUE)
#August and November Months
AugNov = HPlate %>% filter(str_detect(HPlate$month, "aug")|str_detect(HPlate$month, "nov"))
names(dat2)
head(names(dat2))
dat2[1:5, 1:20]
#making sure that non of the genotype information was matched to more than on obs
bad = intersect(June$Barcode, AugNov$Barcode)
length(bad)
bad = AugNov %>% filter(str_detect(AugNov$sampleID.exp, bad) == TRUE)
bad = merge(bad, AugNov, by = "sampleID.exp")
AugNov = merge(AugNov, dat2, by = "sampleID.exp")
match(bad, AugNov$Barcode)
match(AugNov$Barcode, bad)
a = c(1,2,3,4,5)
b = c(6,7,1,2,3)
match(a, b)
b = c(7,1,2,3)
match(a, b)
match(bad, AugNov$Barcode)
bad
#making sure that non of the genotype information was matched to more than on obs
bad = as.matrix(intersect(June$Barcode, AugNov$Barcode))
bad
#making sure that non of the genotype information was matched to more than on obs
bad =intersect(June$Barcode, AugNov$Barcode)
bad
print(bad)
intersect(June$Barcode, AugNov$Barcode)
### Sample plan data cleaning ###
library(stringr)
library(tidyverse)
library(dplyr)
setwd("C:/Users/twili/Desktop/GIThub/Andrew/stapleton_lab/Stress_Splicing/SamplingPlan")
#############################################
##### formatting the Sampling Plan data #####
#############################################
dat = read.csv(file = "../2016_Clayton/Field Book (2016) - Clayton - Sampling Plan_TIDIED.csv", header = TRUE)
#filter out the recongizable MO###
dat = dat %>% filter(str_detect(dat$Genotype, "Mo") == TRUE)
#create the breedtype category
BreedType = ifelse(substr(dat$Genotype, 1,1)=="M", "Inbred", "Hybrid")
dat = cbind(BreedType, dat)
snpFull = read.csv(file = "../IBM94markerset08seq.csv", header = TRUE)
snp = snpFull[,-(1:5)]
#############################################
### matching the Mo### to their snp Values ##
#############################################
library(data.table)
#function takes the last n characters of a string
substrRight <- function(x, n){
substr(x, nchar(x)-n+1, nchar(x))
}
#creating datasets exclusively containing the last three numbers
dat.num =cbind(dat, as.integer(substrRight(as.character(dat$Genotype), 3)))
#produces warning sign about NA's for data that is not availible for invalid Mo###
snp.num = as.integer(substrRight(as.character(colnames(snp)), 3))
snp.new = data.frame(lapply(snp,as.character),stringsAsFactors=FALSE)
snpMatch = rbind(snp.num,snp.new)
snpMatch = transpose(snpMatch)
# creating matching Genotype columns to merge the data
#need = c(1,5,7,8,9,10,16) #column numbers of needed variables
#dat.num = dat.num[,need]
colnames(snpMatch) = "GenotypeNum"
#datnames =names(dat.num)
colnames(dat.num)[17] = "GenotypeNum"
dat2 = merge(dat.num,snpMatch, by.x = "GenotypeNum", by.y = "GenotypeNum",all.MoNum = all)
dat2 = dat2[order(dat2$Genotype, decreasing = FALSE),]
dat2 = dat2[,-c(1, 4)] #omit GenotypeNum
dat2[1:20, 1:20]
#write.csv(dat2, "SamplingPlan_dat2.csv")
########################################
######### Including plate data #########
########################################
colnames(dat2)[2] = "sampleID.exp"
# ### by month framing ####
#
# # 2018_11 plate data #
# ### the file in plate will come from the qPCR output including stress ratios ###
# plate_11 = read.csv(file = "../2018_11/2018_11_withStress.csv", header = TRUE)
# colnames(plate_11)[2] = "sampleID"
# full_11 = merge(plate_11, dat2, by = "sampleID")
#
# # 2018_6 plate data #
# plate_6 = read.csv(file = , header = TRUE)
# colnames(plate_6)[2] = "sampleID"
# full_6 = merge(plate_6, dat2, by = "sampleID")
#
# # 2018_8 plate data #
# plate_8 = read.csv(file = , header = TRUE)
# colnames(plate_8)[2] = "sampleID"
# full_8 = merge(plate_8, dat2, by = "sampleID")
#
# #create one big dataframe containing all plate months
# #full = rbind(full_11, full_6, full_8)
#
# #### Heirarchical Model Framing ####
HPlate = read.csv(file = "../Heirarchical/Hierarchical_exp_data_stress.csv")
#split isolate the June month since the sampleID is availible for it
June = HPlate %>% filter(str_detect(HPlate$month, "june") == TRUE)
colnames(June)[2] = "Barcode"
June = merge(June, dat2, by = "Barcode")
#August and November Months
AugNov = HPlate %>% filter(str_detect(HPlate$month, "aug")|str_detect(HPlate$month, "nov"))
AugNov = merge(AugNov, dat2, by = "sampleID.exp")
#making sure that non of the genotype information was matched to more than on obs
bad =intersect(June$Barcode, AugNov$Barcode)
length(bad)
bad
match(bad, AugNov$Barcode)
AugNov[match(bad, AugNov$Barcode),1:10]
AugNov[match(bad, AugNov$Barcode),1:20]
baddoup = AugNov[match(bad, AugNov$Barcode),1:20]
baddoup$month
quiz = c(96.03, 100, 96.3, 100, 100, 100, 100, 88.89, 100, 97.5, 89.66, 100, 100, 100, 100, 57.78, 100, 100, 100)
tests = c(100,46.16, 73.18)
final = 100
grade= mean(quiz)*.21+sum(.18*tests)+final*.25
grade
46.16+73.18
/2
119.34/2
tests = c(59.67,46.16, 73.18)
final = 100
grade= mean(quiz)*.21+sum(.18*tests)+final*.25
grade
.18*3
grade2 = mean(quiz)*.21 + mean(tests)*.54 + final*.25
grade2
tests = c(100,46.16, 73.18)
final = 100
grade= mean(quiz)*.21+sum(.18*tests)+final*.25
grade
